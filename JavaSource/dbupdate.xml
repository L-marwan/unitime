<?xml version="1.0" encoding="UTF-8"?>

<!-- 
 * UniTime 3.0 (University Course Timetabling & Student Sectioning Application)
 * Copyright (C) 2007, UniTime.org
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 -->

<dbupdate>
	<dialect type="mysql">org.hibernate.dialect.MySQLInnoDBDialect</dialect>
	<dialect type="plsql">org.hibernate.dialect.OracleDialect</dialect>
	<update version="1" date="11-Jun-2007" comment="Package Renames, Column Renames">
		<sql>
			update %SCHEMA%.solver_info_def set implementation=replace(implementation,'edu.purdue.smas','org.unitime') where implementation like 'edu.purdue.smas%'
		</sql>
		<sql>
			update %SCHEMA%.solver_parameter_def set default_value=replace(default_value,'edu.purdue.smas','org.unitime') where default_value like 'edu.purdue.smas%'
		</sql>
		<sql>
			update %SCHEMA%.change_log set obj_type=replace(obj_type,'edu.purdue.smas','org.unitime') where obj_type like 'edu.purdue.smas%'
		</sql>
		<plsql onFail="done">
			alter table %SCHEMA%.tmtbl_mgr_to_roles rename column primary to is_primary
		</plsql>
		<mysql onFail="done">
			alter table %SCHEMA%.tmtbl_mgr_to_roles change column `primary` is_primary int(1) null
		</mysql>
	</update>
	<update version="2" date="13-Jul-2007" comment="Room group feature abbv">
		<plsql onFail="next">
			alter table %SCHEMA%.room_feature add abbv varchar2(20)
		</plsql>
		<plsql onFail="next">
			alter table %SCHEMA%.room_group add abbv varchar2(20)
		</plsql>
		<mysql onFail="next">
			alter table %SCHEMA%.room_feature add abbv varchar(20) binary null
		</mysql>
		<mysql onFail="next">
			alter table %SCHEMA%.room_group add abbv varchar(20) binary null
		</mysql>
	</update>
	<update version="3" date="13-Jul-2007" comment="On fly student sectioning">
		<sql onEqual="done" value="1">
			select count(*) from %SCHEMA%.solver_parameter_group g where g.name='OnFlySectioning'
		</sql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_group (uniqueid, name, description, ord) values 
			(%SCHEMA%.solver_parameter_group_seq.nextval, 'OnFlySectioning', 'On Fly Student Sectioning', -1)
		</plsql>
		<plsql>
			update %SCHEMA%.solver_parameter_group g set g.ord = ( select max(x.ord)+1 from %SCHEMA%.solver_parameter_group x )
			where g.name='OnFlySectioning'
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def (select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
			'OnFlySectioning.Enabled' as name, 'false' as default_value, 
			'Enable on fly sectioning (if enabled, students will be resectioned after each iteration)' as description,
			'boolean' as type, 0 as ord, 1 as visible, 
			uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='OnFlySectioning')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def (select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid,
			'OnFlySectioning.Recursive' as name, 'true' as default_value,
			'Recursively resection lectures affected by a student swap' as description,
			'boolean' as type, 1 as ord, 1 as visible,
			uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='OnFlySectioning')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def (select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid,
			'OnFlySectioning.ConfigAsWell' as name, 'false' as default_value,
			'Resection students between configurations as well' as description,
			'boolean' as type, 2 as ord, 1 as visible,
			uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='OnFlySectioning')
		</plsql>
		<mysql into="ID">
			select next_hi from %SCHEMA%.hibernate_unique_key			
		</mysql>
		<mysql into="ORD">
			select max(ord)+1 from %SCHEMA%.solver_parameter_group
		</mysql>
		<mysql>
			insert into %SCHEMA%.solver_parameter_group (uniqueid, name, description, ord) values
			(%ID%, 'OnFlySectioning', 'On Fly Student Sectioning', %ORD%)
		</mysql>
		<mysql>
			insert into %SCHEMA%.solver_parameter_def
			(uniqueid, name, default_value, description, type, ord, visible, solver_param_group_id) values
			(%ID%+1, 'OnFlySectioning.Enabled', 'false', 'Enable on fly sectioning (if enabled, students will be resectioned after each iteration)', 'boolean', 0, 1, %ID%),
			(%ID%+2, 'OnFlySectioning.Recursive', 'true', 'Recursively resection lectures affected by a student swap', 'boolean', 1, 1, %ID%),
			(%ID%+3, 'OnFlySectioning.ConfigAsWell', 'false', 'Resection students between configurations as well', 'boolean', 2, 1, %ID%) 
		</mysql>
		<mysql>
			update %SCHEMA%.hibernate_unique_key set next_hi=next_hi+4
		</mysql>
	</update>
	<update version="4" date="22-Aug-2007" comment="Timetable Grid Fix">
		<sql>
			update %SCHEMA%.user_data set value='-100' where name='TimetableGridTable.week' and value='-1'
		</sql>
	</update>
	<update version="5" date="04-Sep-2007" comment="Application config name size">
		<plsql onFail="done">
			alter table %SCHEMA%.application_config modify name varchar2(512)
		</plsql>
		<mysql onFail="done">
			alter table %SCHEMA%.application_config modify name varchar(512) binary not null
		</mysql>
	</update>
	<update version="6" date="15-Oct-2007" comment="Lastlike course demand permid">
		<mysql onFail="next">
			create index idx_ll_course_demand_permid on %SCHEMA%.lastlike_course_demand(course_perm_id)
		</mysql>
		<mysql onFail="next">
			alter table %SCHEMA%.course_offering modify perm_id varchar(20) binary null
		</mysql>
		<plsql onFail="next">
			create index %SCHEMA%.idx_ll_course_demand_permid on %SCHEMA%.lastlike_course_demand(course_perm_id)
		</plsql>
		<plsql onFail="next">
			alter table %SCHEMA%.course_offering drop constraint nn_course_offering_perm_id
		</plsql>
		<sql>
			update %SCHEMA%.lastlike_course_demand set course_perm_id = null where course_perm_id = '-1'
		</sql>
		<sql>
			update %SCHEMA%.course_offering set perm_id = null where perm_id = '-1'
		</sql>
	</update>
	<update version="7" date="16-Oct-2007" comment="IType Abbreviation">
		<sql onFail="next">
			update %SCHEMA%.itype_desc set abbv=smas_abbv where trim(abbv) is null or trim(abbv) = ''
		</sql>
		<sql onFail="next">
			alter table %SCHEMA%.itype_desc drop column smas_abbv
		</sql>
	</update>
	<update version="8" date="25-Oct-2007" comment="Distribution Pref add column">
		<plsql onFail="next">
			alter table %SCHEMA%.distribution_pref add uid_rolled_fwd_from number(20)
		</plsql>
		<mysql onFail="next">
			alter table %SCHEMA%.distribution_pref add uid_rolled_fwd_from decimal(20,0) null
		</mysql>
	</update>
	<update version="9" date="27-Nov-2007" comment="ItypeDesc parent">
		<plsql onFail="next">
			alter table %SCHEMA%.itype_desc add parent number(2)
		</plsql>
		<mysql onFail="next">
			alter table %SCHEMA%.itype_desc add parent int(2)
		</mysql>
		<plsql onFail="next">
			alter table %SCHEMA%.itype_desc add constraint fk_itype_parent foreign key (parent) references %SCHEMA%.itype_desc(itype)
		</plsql>
		<mysql onFail="next">
			alter table %SCHEMA%.itype_desc add constraint fk_itype_parent foreign key fk_itype_parent (parent) references %SCHEMA%.itype_desc(itype)
		</mysql>
		<plsql><![CDATA[
			update %SCHEMA%.itype_desc x set x.parent=(select max(i.itype) from %SCHEMA%.itype_desc i where i.itype<x.itype and i.basic=1) where x.basic=0
		]]></plsql>
		<mysql><![CDATA[
			create table %SCHEMA%.itype_dummy as (select i.itype, max(x.itype) as parent from %SCHEMA%.itype_desc i, %SCHEMA%.itype_desc x where i.basic=0 and x.basic=1 and x.itype<i.itype group by i.itype)
		]]></mysql>
		<mysql>
			update %SCHEMA%.itype_desc i set i.parent=(select x.parent from %SCHEMA%.itype_dummy x where x.itype=i.itype)
		</mysql>
		<mysql>
			drop table %SCHEMA%.itype_dummy
		</mysql>
	</update>
	<update version="10" date="29-Nov-2007" comment="Course offering cache number of last-like course demands">
		<mysql>
			alter table %SCHEMA%.course_offering add lastlike_demand bigint(10) not null default 0
		</mysql>
		<plsql>
			alter table %SCHEMA%.course_offering add lastlike_demand number(10) default 0
		</plsql>
		<plsql>
			alter table %SCHEMA%.course_offering add constraint nn_course_offering_ll_demand check (lastlike_demand is not null)
		</plsql>
		<sql>
			update %SCHEMA%.course_offering co set co.lastlike_demand = (
				select count(distinct cod.student_id) from %SCHEMA%.lastlike_course_demand cod
				where co.subject_area_id=cod.subject_area_id and co.course_nbr=cod.course_nbr
			) where co.perm_id is null
		</sql>
		<sql>
			update %SCHEMA%.course_offering co
			set co.lastlike_demand = (
				select count(distinct cod.student_id) from %SCHEMA%.lastlike_course_demand cod, %SCHEMA%.subject_area sa, %SCHEMA%.student s
				where co.perm_id=cod.course_perm_id and co.subject_area_id=sa.uniqueid and
				cod.student_id=s.uniqueid and s.session_id=sa.session_id
			) where co.perm_id is not null
		</sql>
	</update>
	<update version="11" date="07-Feb-2008" comment="Examination timetabling">
		<!-- Table DISTRIBUTION_TYPE, add column exam_pref (boolean) -->
		<plsql>alter table %SCHEMA%.distribution_type add exam_pref number(1) default 0</plsql>
		<mysql>alter table %SCHEMA%.distribution_type add exam_pref int(1) default 0</mysql>
		<!-- Added few exam distribution types (same period, same room, precedence) -->
		<plsql><![CDATA[
			insert into %SCHEMA%.distribution_type (uniqueid, reference, label, sequencing_required, req_id, allowed_pref, description, abbreviation, instructor_pref, exam_pref) values
			(%SCHEMA%.ref_table_seq.nextval, 'EX_SAME_PER', 'Same Period', 0, 36, 'P43210R', 'Exams are to be placed at the same period. <BR>When prohibited or (strongly) discouraged: exams are to be placed at different periods.', 'Same Per', 0, 1)
		]]></plsql>
		<plsql><![CDATA[
			insert into %SCHEMA%.distribution_type (uniqueid, reference, label, sequencing_required, req_id, allowed_pref, description, abbreviation, instructor_pref, exam_pref) values
			(%SCHEMA%.ref_table_seq.nextval, 'EX_SAME_ROOM', 'Same Room', 0, 37, 'P43210R', 'Exams are to be placed at the same room(s). <BR>When prohibited or (strongly) discouraged: exams are to be placed at different rooms.', 'Same Room', 0, 1);
		]]></plsql>
		 <plsql><![CDATA[
		 	insert into %SCHEMA%.distribution_type (uniqueid, reference, label, sequencing_required, req_id, allowed_pref, description, abbreviation, instructor_pref, exam_pref) values
		 	(%SCHEMA%.ref_table_seq.nextval, 'EX_PRECEDENCE', 'Precedence', 1, 38, 'P43210R', 'Exams are to be placed in the given order. <BR>When prohibited or (strongly) discouraged: exams are to be placed in the order reverse to the given one.', 'Precede', 0, 1);
		 ]]></plsql>
		<mysql into="ID">
			select next_hi from %SCHEMA%.hibernate_unique_key			
		</mysql>
		<mysql> <![CDATA[
			insert into %SCHEMA%.distribution_type (uniqueid, reference, label, sequencing_required, req_id, allowed_pref, description, abbreviation, instructor_pref, exam_pref) values 
			(%ID%, 'EX_SAME_PER', 'Same Period', 0, 36, 'P43210R', 'Exams are to be placed at the same period. <BR>When prohibited or (strongly) discouraged: exams are to be placed at different periods.', 'Same Per', 0, 1), 
			(%ID%+1, 'EX_SAME_ROOM', 'Same Room', 0, 37, 'P43210R', 'Exams are to be placed at the same room(s). <BR>When prohibited or (strongly) discouraged: exams are to be placed at different rooms.', 'Same Room', 0, 1), 
			(%ID%+2, 'EX_PRECEDENCE', 'Precedence', 1, 38, 'P43210R', 'Exams are to be placed in the given order. <BR>When prohibited or (strongly) discouraged: exams are to be placed in the order reverse to the given one.', 'Precede', 0, 1); 
		 ]]></mysql>
		<!-- Add exam start date to sessions -->	
		<plsql>alter table %SCHEMA%.sessions add exam_begin_date date</plsql>
		<plsql>update %SCHEMA%.sessions set exam_begin_date = session_begin_date_time+112</plsql>
		<mysql>alter table %SCHEMA%.sessions add exam_begin_date datetime</mysql>
		<mysql>update %SCHEMA%.sessions set exam_begin_date = adddate(session_begin_date_time,112)</mysql>	
		<sql>alter table %SCHEMA%.sessions add constraint nn_sessions_exam_begin_date check (exam_begin_date is not null)</sql>
		<!-- Create table exam_period -->
		<plsql>
			create table %SCHEMA%.exam_period (
				uniqueid number(20,0) constraint nn_exam_period_uniqueid not null,
				session_id number(20,0) constraint nn_exam_period_session not null,
				date_ofs number(10,0)  constraint nn_exam_period_date_ofs not null,
				start_slot number(10,0)  constraint nn_exam_period_start_slot not null,
				length number(10,0)  constraint nn_exam_period_length not null,
				pref_level_id number(20,0) constraint nn_exam_period_pref not null
			)
		</plsql>
		<plsql>alter table %SCHEMA%.exam_period add constraint pk_exam_period primary key (uniqueid)</plsql>
		<mysql>
			create table %SCHEMA%.exam_period (
				uniqueid decimal(20,0) primary key not null,
				session_id decimal(20,0) not null,
				date_ofs bigint(10)  not null,
				start_slot bigint(10)  not null,
				length bigint(10)  not null,
				pref_level_id decimal(20,0) not null
			)
		</mysql>
		<sql>
			alter table %SCHEMA%.exam_period add constraint fk_exam_period_session foreign key (session_id)
			references %SCHEMA%.sessions (uniqueid) on delete cascade
		</sql>
		<sql>
			alter table %SCHEMA%.exam_period add constraint fk_exam_period_pref foreign key (pref_level_id)
			references %SCHEMA%.preference_level (uniqueid) on delete cascade
		</sql>
		<!-- Rooms, and non-university locations - added columns exam_enable (boolean), exam_capacity (exam seating capacity, int), exam_pref (exam period preferences) -->
		<plsql>alter table %SCHEMA%.room add exam_enable number(1) default 0</plsql>
		<plsql>alter table %SCHEMA%.room add exam_capacity number(10) default 0</plsql>
		<plsql>alter table %SCHEMA%.room add exam_pref varchar2(1000)</plsql>
		<plsql>update %SCHEMA%.room set exam_capacity = capacity /2</plsql>
		<plsql>alter table %SCHEMA%.non_university_location add exam_enable number(1) default 0</plsql>
		<plsql>alter table %SCHEMA%.non_university_location add exam_capacity number(10) default 0</plsql>
		<plsql>alter table %SCHEMA%.non_university_location add exam_pref varchar2(1000)</plsql>
		<mysql>alter table %SCHEMA%.room add exam_enable int(1) default 0</mysql>
		<mysql>alter table %SCHEMA%.room add exam_capacity bigint(10) default 0</mysql>
		<mysql>alter table %SCHEMA%.room add exam_pref varchar(1000)</mysql>
		<mysql>update %SCHEMA%.room set exam_capacity = capacity /2</mysql>
		<mysql>alter table %SCHEMA%.non_university_location add exam_enable int(1) default 0</mysql>
		<mysql>alter table %SCHEMA%.non_university_location add exam_capacity bigint(10) default 0</mysql>
		<mysql>alter table %SCHEMA%.non_university_location add exam_pref varchar(1000)</mysql>
		<!-- Create exam manager role -->
		<plsql>insert into %SCHEMA%.roles (role_id, reference, abbv) values (%SCHEMA%.ROLE_SEQ.nextval, 'Exam Mgr', 'Examination Timetabling Manager')</plsql>
		<mysql>insert into %SCHEMA%.roles (role_id, reference, abbv) values (%ID%+3, 'Exam Mgr', 'Examination Timetabling Manager')</mysql>
		<mysql>update %SCHEMA%.hibernate_unique_key set next_hi=%ID%+4</mysql>
		<!-- Create table exam -->
		<plsql>
			create table %SCHEMA%.exam (
				uniqueid number(20,0) constraint nn_exam_uniqueid not null,
				session_id number(20,0) constraint nn_exam_session not null,
				name varchar2(100),
				note varchar2(1000),
				length number(10,0) constraint nn_exam_length not null,
				max_nbr_rooms number(10,0) default 1 constraint nn_exam_nbr_rooms not null,
				seating_type number(10,0) constraint nn_exam_seating not null,
				assigned_period number (20,0)
			)
		</plsql>
		<plsql>alter table %SCHEMA%.exam add constraint pk_exam primary key (uniqueid)</plsql>
		<mysql>
			create table %SCHEMA%.exam (
				uniqueid decimal(20,0) primary key not null,
				session_id decimal(20,0) not null,
				name varchar(100),
				note varchar(1000),
				length bigint(10) not null,
				max_nbr_rooms bigint(10) default 1 not null,
				seating_type bigint(10) not null,
				assigned_period decimal(20,0)
			)
		</mysql>
		<sql>
			alter table %SCHEMA%.exam add constraint fk_exam_session foreign key (session_id)
			references %SCHEMA%.sessions (uniqueid) on delete cascade
		</sql>
		<sql>
			alter table %SCHEMA%.exam add constraint fk_exam_period foreign key (assigned_period)
			references %SCHEMA%.exam_period (uniqueid) on delete cascade
		</sql>
		<!-- Create relation between exams and other objects (classes, configs, courses etc.) -->
		<plsql>
			create table %SCHEMA%.exam_owner (
				uniqueid number(20,0) constraint nn_exam_owner_unique_id not null,
				exam_id number(20,0) constraint nn_exam_owner_exam_id not null,
				owner_id number(20,0) constraint nn_exam_owner_owner_id not null,
				owner_type number(10,0) constraint nn_exam_owner_owner_type not null
			)
		</plsql>
		<plsql>alter table %SCHEMA%.exam_owner add constraint pk_exam_owner primary key (uniqueid)</plsql>
		<mysql>
			create table %SCHEMA%.exam_owner (
				uniqueid decimal(20,0) primary key not null,
				exam_id decimal(20,0) not null,
				owner_id decimal(20,0) not null,
				owner_type bigint(10) not null
			)
		</mysql>
		<sql>
			alter table %SCHEMA%.exam_owner add constraint fk_exam_owner_exam foreign key (exam_id)
			references %SCHEMA%.exam (uniqueid) on delete cascade;
		</sql>
		<plsql>create index %SCHEMA%.idx_exam_owner_exam on %SCHEMA%.exam_owner(exam_id)</plsql>
		<plsql>create index %SCHEMA%.idx_exam_owner_owner on %SCHEMA%.exam_owner(owner_id, owner_type)</plsql>
		<mysql>create index idx_exam_owner_exam on %SCHEMA%.exam_owner(exam_id)</mysql>
		<mysql>create index idx_exam_owner_owner on %SCHEMA%.exam_owner(owner_id, owner_type)</mysql>
		<!-- Create table exam_room_assignment (relation exam - location) -->
		<plsql>
			create table %SCHEMA%.exam_room_assignment (
				exam_id number(20,0) constraint nn_exam_room_exam_id not null,
				location_id number(20,0) constraint nn_exam_room_location_id not null
			)
		</plsql>
		<plsql>alter table %SCHEMA%.exam_room_assignment add constraint pk_exam_room_assignment primary key (exam_id, location_id)</plsql>
		<mysql>
			create table %SCHEMA%.exam_room_assignment (
				exam_id decimal(20,0) not null,
				location_id decimal(20,0) not null,
				primary key (exam_id, location_id)
			)
		</mysql>
		<sql>
			alter table %SCHEMA%.exam_room_assignment add constraint fk_exam_room_exam foreign key (exam_id)
			references %SCHEMA%.exam (uniqueid) on delete cascade
		</sql>
		<!-- Added exam period preferences -->
		<plsql>
			create table %SCHEMA%.exam_period_pref (
				uniqueid number(20,0) constraint nn_exam_period_pref_uniqueid not null,
				owner_id number(20,0) constraint nn_exam_period_pref_owner not null,
				pref_level_id number(20,0) constraint nn_exam_period_pref_pref not null,
				period_id number(20,0) constraint nn_exam_period_pref_period not nul
			)
		</plsql>
		<plsql>alter table %SCHEMA%.exam_period_pref add constraint pk_exam_period_pref primary key (uniqueid)</plsql>
		<mysql>
			create table %SCHEMA%.exam_period_pref (
				uniqueid decimal(20,0) primary key not null,
				owner_id decimal(20,0) not null,
				pref_level_id decimal(20,0) not null,
				period_id decimal(20,0) not null
			)
		</mysql>
		<sql>
			alter table %SCHEMA%.exam_period_pref add constraint fk_exam_period_pref_pref foreign key (pref_level_id)
			references %SCHEMA%.preference_level (uniqueid) on delete cascade
		</sql>
		<sql>
			alter table %SCHEMA%.exam_period_pref add constraint fk_exam_period_pref_period foreign key (period_id)
			references %SCHEMA%.exam_period (uniqueid) on delete cascade
		</sql>
		<!-- Instructor assignment -->
		<plsql>
			create table %SCHEMA%.exam_instructor (
				exam_id number(20,0) constraint nn_exam_instructor_exam not null,
				instructor_id number(20,0) constraint nn_exam_instructor_instructor not null
			)
		</plsql>
		<plsql>alter table %SCHEMA%.exam_instructor add constraint pk_exam_instructor primary key (exam_id, instructor_id)</plsql>
		<mysql>
			create table %SCHEMA%.exam_instructor (
				exam_id decimal(20,0) primary key not null,
				instructor_id decimal(20,0) not null
			)
		</mysql>
		<sql>
			alter table %SCHEMA%.exam_instructor add constraint fk_exam_instructor_exam foreign key (exam_id)
			references %SCHEMA%.exam (uniqueid) on delete cascade
		</sql>
		<sql>
			alter table %SCHEMA%.exam_instructor add constraint fk_exam_instructor_instructor foreign key (instructor_id)
			references %SCHEMA%.departmental_instructor (uniqueid) on delete cascade
		</sql>
	</update>
</dbupdate>